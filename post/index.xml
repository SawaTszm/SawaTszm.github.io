<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Posts on sawa.md</title>
    <link>https://SawaTszm.github.io/post/</link>
    <description>Recent content in Posts on sawa.md</description>
    <image>
      <title>sawa.md</title>
      <url>https://SawaTszm.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E</url>
      <link>https://SawaTszm.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E</link>
    </image>
    <generator>Hugo -- gohugo.io</generator>
    <language>ja</language>
    <lastBuildDate>Fri, 08 Mar 2024 18:16:03 +0900</lastBuildDate><atom:link href="https://SawaTszm.github.io/post/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>【github】mainではないブランチから派生したブランチでPRを出すとき</title>
      <link>https://SawaTszm.github.io/post/pr-on-a-branch-not-main/</link>
      <pubDate>Fri, 08 Mar 2024 18:16:03 +0900</pubDate>
      
      <guid>https://SawaTszm.github.io/post/pr-on-a-branch-not-main/</guid>
      <description>ベースブランチってどこ向け？
タイトルの通り、main(default)ではないブランチから派生したブランチのPRを出すのに謎の抵抗感があったのですが、githubくんがかなりよしなにしてくれることに気がついたのでその挙動を備忘録として書いておきます。
（知っている人にとってはめちゃくちゃ当たり前体操な内容だと思います）
TL;DR main(default)ブランチから切ったブランチAから更に切ったブランチA2のPRを出すときは、難しいこと考えずにブランチA向けにPR出すのが良き。
どういうこと？ たとえば、チームメンバーがmainから派生したbranchAで作業していたとします。
branchAに乗っている機能が前提の作業をするために、branchAからbranchA2を切りました。
branchA2の作業が終わりPRを出したいのですが、branchAはまだ細かい部分のPR中でmainにはマージされていません。
さて、このbranchA2のPRの向き先はmainかbranchAか、という話です。
今こうして自分で書いていても「いやbranchA向けだろ……」と思うのですが（main向けにPRを出すと、branchAのコミットもPRに乗ってしまうためかなり見づらいことになるので）、
「branchA向けに出したとして、branchAがmainにマージされたらbranchA向けのPRはどういう扱いになるんだ……？　mainでrebase or mergeしてmain向けに直さないといけないのか？」と漠然と面倒臭がっていました。今までは。
この「PRのbaseとなっているブランチがマージされていった後にデフォルトのブランチ向けのPRに直す」作業、githubが勝手にやってくれます。
実例 （ほとんどmainにしかpushしていないprivateリポジトリで実験）
test-branch-Aというブランチををmainから切ってPRを出したとします。
その後、test-branch-Aから切ったtest-branch-A2のPRをtest-branch-A向けに出します。
（PR作成時にbaseが選べるし、作成した後もEDITボタンから変更できます）
この状態でtest-branch-AのPRがマージされると、
Base automatically changed from test-branch-A to mainというログが残って、test-branch-A2のPRがmain向けに自動修正されます。
めちゃくちゃ便利だ……。もっと早く気が付きたかった。
PR出した後は、ベースとなるブランチ自体に先んじてマージしちゃうか、そっちの作業を待ってからmainにマージするか、どちらにせよベースとなるブランチで作業している方とのコミュニケーションは必要ですが、とりあえず派生元にPR出しておけばあんまり困ることは（今のところの経験上）ないです。
派生PR、もう怖くない！な備忘録でした。</description>
    </item>
    
    <item>
      <title>【覚え書き】JavaScriptのプライベートクラス機能</title>
      <link>https://SawaTszm.github.io/post/private-class-field/</link>
      <pubDate>Tue, 20 Jun 2023 23:05:31 +0900</pubDate>
      
      <guid>https://SawaTszm.github.io/post/private-class-field/</guid>
      <description>TypeScriptを使っていると、「ちゃんとprivateとかreadonlyとか使って制約かけないとな〜」と認識し直すタイミングが定期的に来るんですが、
そんな折にJavaScript側で実現できるプライベートクラス機能なるものがあることを知りました。
プライベートクラス機能 - JavaScript | MDN
クラスのフィールドの先頭にハッシュ(#)をつけることで、プライベートなインスタンスフィールドを生成することができます。
あくまでコンパイル時にエラーの判定を行うTypeScriptと異なり、JavaScript自身の機能なのでランタイム時に判定＆エラーを返してくれます。
継承を使う場合は、privateと同じく子クラスからは参照不可になりますが、
子クラス側で同じ名前のプライベートインスタンスフィールドを定義することはできます。
存在を知ってパッと概要を追って、良さそうと思ったけど世の反応（？）はどんな感じなんでしょうか。
（ちなみに、インスタンス生成時に少し遅くなるらしい、と言う旨の去年の記事はお見かけしました: JavaScriptでプライベートを使うと遅くなる話）</description>
    </item>
    
    <item>
      <title>日記(~2023/06)</title>
      <link>https://SawaTszm.github.io/post/diary-2023-06/</link>
      <pubDate>Sat, 17 Jun 2023 15:11:15 +0900</pubDate>
      
      <guid>https://SawaTszm.github.io/post/diary-2023-06/</guid>
      <description>(純然たる日記の寄せ集めです)
(2023/04/01)
ながら聞き用にbocoのPEACE SS-1買いました。
仕事中に音楽とかラジオとか聴きたい派なんですが、ずっとイヤホンをしていると耳が痛いし、中耳炎になって危ないってよく聞くし……と思って数年前にShokz(旧Aftershokz)の骨伝導イヤホンを買ったのが骨伝導との出会いでした。
買った当時は気にならなかったんですが、しばらく経ってちょっといい椅子を導入してヘッドレストにクッションをつけたら首周りの部分が干渉するようになってしまって、ちょっと不便だな〜と思っていたところにPEACE SS-1くんと出会いました。実に快適です。ありがとうboco。
（耳を挟むように押し込むと音量上げたりできるらしいですが、なんか直感的に出来なくてコツが必要＆挟み込み部分の寿命縮めそうなので本体操作は諦めてます）
(2023/06/16)
最近調べ物によくChatGPTを使っていて、便利だなぁと思う反面このままいくと原神のスメール編で学者たちに起きていたこと（聞けばなんでも出してくれるアーカーシャ端末があるから、誰も一次情報に触れようとしなくなる）が自分の中で起こりそうだなぁと漠然と考えたりしてました。
利便性の恩恵を受けつつ、自分で調べ物をする感覚は忘れないように上手く間をとっていきたいです。
(2023/06/17)
応用情報がCBT方式になるのを密かに待っているんですが（基本情報はそれで去年受けた）、長文読解とか記述方式の回答とかの相性の問題で中々導入されないんじゃないか説が結構濃厚な感じがするので、観念して秋季に受けようかなと考え中です。
予定があれば早起きできることを証明したいと思います。</description>
    </item>
    
    <item>
      <title>SSOについて調べたことまとめ</title>
      <link>https://SawaTszm.github.io/post/sumary-sso/</link>
      <pubDate>Sat, 17 Jun 2023 11:06:39 +0900</pubDate>
      
      <guid>https://SawaTszm.github.io/post/sumary-sso/</guid>
      <description>SSO、使う側としてはよく見かけますが実装する側としてはあんまりキャッチアップしてこなかったなと思ったので、軽く調べたのをまとめておきます。
SSOとは シングルサインオン（Single Sign-On、SSO）は、ユーザが1回の認証で複数のアプリケーションにアクセスできるようにする仕組み全般のことを指します。
大きく分けるとSAML（Security Assertion Markup Lnaguage）、OIDC（OpenID Connect）の2つの一般的なプロトコルがあります。（※諸説ある）
SAML SAMLアサーション（ユーザ情報とアクセスできる内容を含む暗号化署名されたXMLドキュメント）を使用してサービス間でID情報を共有します。
ビジネス系（Slack, Office365, Salesforce）などでよく見られる（らしい）です。
OpenID Connect JWT(JSON Web Token)を使用してサービス間でID情報を共有します。
よくお世話になる「GoogleアカウントでYoutubeにログインしている」系はOpenID Connectで実現されています。
代表的な実現方式 （【図解つき】シングルサインオン（SSO）とは？機能や仕組み、導入メリット、デメリットをわかりやすく解説！ | mobiconnect（モビコネクト）を多大に参考にしています、ありがとうございます）
代行認証方式 利用者の代わりにエージェントが認証情報を保持し、ログイン画面を検知したら代行して各システムのID、パスワードを入力する方式です。
（個人的にはこれをSSOと呼んでも良いのか、という気持ちは多少あるけど、パスワード自動生成などで認証情報を意識しないので実質SSO、と言うことなのかもしれない）
システム側でSSOに対応していなくても、ID/パスワードでログインする一般的なシステムであれば使用することができ、活用範囲が広いです。
その代わり、利用者側のPC（もしくはWebブラウザ）に常駐するエージェントを必ず入れる必要があります。
リバースプロキシ方式 Web上で実現するSSOの仕組みとして、アクセスを全てリバースプロキシと呼ばれる中継サーバを介して行うようにネットワークを設計する方式です。
リバースプロキシに対して認証を行うと、認証済みのCookieが発行され、各サイトにアクセスできるようになります。 対象としたいシステムに何か導入する必要がないため、既存システムへの影響がほぼない状態で事前検証ができます。が、リバースプロキシがボトルネックになる可能性があります。
実装する場合はざっくり以下のような構成になります:
Nginx等を使用して、アプリケーションへのリバースプロキシをセットアップ SSOプロバイダの設定（色々あるので最適なものを選ぶ） アプリケーション側の認証ビュー（API）の実装 エージェント方式 リバースプロキシ方式同様、Web上で実現するSSOの仕組みで、Webサーバやアプリケーションサーバにエージェントソフトウェアを組み込む方式です。
組み込んだモジュールがSSOサーバと連携することでSSOを実現します。
リバースプロキシと異なり、ボトルネックが発生しづらい、既存のネットワーク環境に変更を加えなくて良い点がメリットです。
SAML認証方式 SAML認証方式は、IdP（Identity Provider）とSP（Service Provider）の2つの要素で構成され、SP側（Webサーバやアプリケーション側）をSAMLに対応させることで、IdPが提供する認証情報を利用してSSOを実現できます。
（名前がすごくややこしいけど、別に他の方式がSAMLプロトコルを使わないと言うわけではなくて、この方式の説明の意図は「上二つの方式と異なりWeb上で完結せず、アプリケーション側でSAMLに対応するSSO方式」ってことだと思います）
まとめ 認証まわりって難しいですね。
（見ている途中でソーシャル認証やOAuth2あたりの情報も出てきましたがちょっとパンクしてきたのでここで止めておきます）
参考 シングルサインオンとは｜「分かりそう」で「分からない」でも「分かった」気になれるIT用語辞典 【図解つき】シングルサインオン（SSO）とは？機能や仕組み、導入メリット、デメリットをわかりやすく解説！ | mobiconnect（モビコネクト） What Is Single Sign-on (SSO)? How It Works - YouTube 後で見たい Django SSO - YouTube </description>
    </item>
    
    <item>
      <title>Flutter周りで知ったことまとめ</title>
      <link>https://SawaTszm.github.io/post/diary-2023-03-11-about-flutter/</link>
      <pubDate>Sat, 11 Mar 2023 20:43:27 +0900</pubDate>
      
      <guid>https://SawaTszm.github.io/post/diary-2023-03-11-about-flutter/</guid>
      <description>最近個人でFlutterを触っていて楽しいので色々調べていて、その時知ったことや勉強会で聞かせてもらった話などのまとめ。
（「こんな便利なものあるんだ〜」と思っても一回ブラウザのタブを開いちゃうと忘れがちなので、自分用のリンク集として）
Material Design3 https://m3.material.io/
Material 3 is the latest version of Google’s open-source design system. Design and build beautiful, usable products with Material 3.
(拙訳) Material 3 は、Google のオープンソース デザイン システムの最新バージョンです。 Material 3 を使用して、美しく使いやすい製品を設計および構築します。
Googleのデザイナーと開発者によって構築・サポートされている、オープンソースなデザインシステム。
Android, Flutter, そしてWeb向けのUXガイダンス・UIコンポーネントの実装が含まれている。 PrimaryColorを選択するだけでいい感じに各色設定してくれたりするので便利。
（絶対それ以外の便利な使い方もある）
// ThemeDataで指定する ThemeData( useMaterial3: true, colorSchemeSeed: Colors.XXX, // 好きな色 ) これだけでデフォルトの「テストです！！！」と言わんばかりの真っ青なヘッダが変わるのでちょっと「おぉ……」ってなる。
DartPad https://dartpad.dev/
Dartの構文を気軽に試せる。便利。
ちなみに、新しいバージョンを試したいときは下のstable channelを押して切り替える。
Serverpod https://serverpod.dev/
reverpodならぬServerPod。
Flutterコミュニティ向けに、Dartで書かれたOSSのアプリサーバ。
isar https://isar.dev/
hiveのv2系としてのプロジェクトらしい？
Flutterで使うデータベース。詳しくはこれから調べる。</description>
    </item>
    
    <item>
      <title>Python: requestsのタイムアウトエラーについて</title>
      <link>https://SawaTszm.github.io/post/python-requests-timeout/</link>
      <pubDate>Wed, 08 Mar 2023 16:47:00 +0900</pubDate>
      
      <guid>https://SawaTszm.github.io/post/python-requests-timeout/</guid>
      <description>pythonでHTTP通信するときに大体使うrequestsで、timeoutエラーの種類で問題の切り分けがしたくて調べたのでちょっとまとめ。
TL;DR 公式ドキュメントのExceptionsを見るとわかりやすい。
中でもタイムアウト関連のエラーは以下の二つ:
connect timeout requests.exceptions.ConnectTimeout例外が投げられる。
相手のサーバと接続を確立する時に時間がかかりすぎたtimeout。
公式ドキュメント
read timeout requests.exceptions.ReadTimeout例外が投げられる。
相手のサーバからレスポンスが返ってくるまでに時間がかかりすぎたtimeout。
公式ドキュメント
両方まとめてcatchしたい時は requests.exceptions.Timeout例外が設定されていて、ConnectTimeout, ReadTimeoutどちらも含まれます。
もうちょっと詳しく そもそもRequestsの例外の中には、RequestException（曖昧な例外）やConnectionErrorが設定されていて、明らかに設定がおかしい場合や早期に接続エラーが起きた場合には、レスポンスを待つ前にこの例外が投げられます。
それらが起きずにtimeoutエラーが起きた場合は、接続の確立で相手からレスポンスが返ってこない(ConnectTimeout)か、接続確率はできてるけど接続先がデータの準備などで時間がかかりすぎて設定したtimeout時間内にレスポンスが返ってこない(Readtimeout)かの二択。
なので、ConnectTimeoutが起きた時には安全に再試行できると公式ドキュメントにも書かれてます（少なくともリクエスト時の設定に問題がある訳じゃないから）。
Timeout例外が出た時にする事は下記の感じになると思います:
ConnectTimeoutが出た場合は、リクエストを投げてる相手のサーバがダウンしてないか、ネットワーク設定に問題がないかを確認する。 ReadTimeoutが出た場合は、接続の確立には成功していて、向こうのレスポンスに時間がかかっているので、リクエストするサーバ側にも責任がある場合はチューニングする。そうでない場合は一度timeout時間を伸ばして成功するか様子を見る。 デフォルトのtimeout時間は設定されていないので注意する 明示的に設定しない限り、timeoutのデフォルトはNoneです。つまりtimeoutしません。
基本的にはtimeoutを設定して、上記のtimeoutエラーで原因がわかるようにした方が良さそうです。
import requests try: # connect timeout, read timeoutどちらも同じ値で良い場合 res = requests.get(&amp;#39;有効なURL&amp;#39;, timeout=30) # connect timeout=30, read timeout=60とかで分けたい場合 res = requests.get(&amp;#39;有効なURL&amp;#39;, timeout=(30, 60)) except requests.exceptions.ConnectTimeout: print(&amp;#34;接続確立のエラー&amp;#34;) except requests.exceptions.ReadTimeout: print(&amp;#34;レスポンスが遅すぎたエラー&amp;#34;) </description>
    </item>
    
    <item>
      <title>Wakatime導入してみた</title>
      <link>https://SawaTszm.github.io/post/install-wakatime/</link>
      <pubDate>Tue, 28 Feb 2023 23:40:16 +0900</pubDate>
      
      <guid>https://SawaTszm.github.io/post/install-wakatime/</guid>
      <description>個人開発でアプリ出したいなぁと思っていて（今はFlutterくんと仲良くなるためにチュートリアルやってるだけですが）、毎日少しずつでもコーディングするモチベーションが欲しい……！と思ってwakatimeを導入しました。
wakatimeは、VSCodeなどのエディタと連携して、実際にコーディングしている時間を計測してくれるサービスです。
ちょうど最近登録したLAPRAS(GithubやTwitterなどからクローリングした情報をまとめてポートフォリオにしてくれるサービス)のbeta版機能として連携できるようになっていて知りました。
個人で使っているPCのVSCodeにだけ導入しておけば、完全に個人でコーディングしている時間を集計できるのが良さげです。
インストール&amp;amp;セットアップ サイトからgithubでサインアップ settingsにあるSecret API Keyをコピーしておく VSCodeの拡張機能でwakatimeをインストール インストールが終わるとAPIKeyの入力を求められるのでペースト これだけです。ダッシュボードは割とリアルタイムに反映されるので、少しコードを触って見に行くと集計されてます。
どのリポジトリを触ったか、どの言語を触ったか、更にはデバッグしていた時間なども記録されてました。
profileに反映されるのは少し時間がかかりますが、少しすると表示され始めます:
（githubのProfileにバッジも置いてみた）
結論: 良さそう 最初は「ブログでもzennの記事書くときでも結構だらだらmdファイル触るし、触った言語比率とかそういうのpublicになるとちょっと恥ずかしいな〜」みたいな謎のプライド(？)で導入を悩んでいたんですが、公表するデータは制御できるし、最初から気軽な気持ちで導入しておけばよかったなと思いました。
サイト内でコーディング時間のゴールも設定できる&amp;amp;profileの草形式で自分の頑張りが見られるので、モチベーションアップに繋がりそうです。
(個人で触るコードのみの環境なのでサクッと導入しましたが、仕事上の守秘義務のあるコードを触る環境なんかに入れる時はセキュリティ的にちゃんと色々調べないといけないと思います。)</description>
    </item>
    
    <item>
      <title>Hugoを使用しているサイトでmermaidを記述できるようにする</title>
      <link>https://SawaTszm.github.io/post/use-mermaid-in-hugo-blog/</link>
      <pubDate>Wed, 14 Dec 2022 19:20:31 +0900</pubDate>
      
      <guid>https://SawaTszm.github.io/post/use-mermaid-in-hugo-blog/</guid>
      <description>最近読んだGoF本を記事としてまとめたくて、このサイト内でmermaidを記述したかったので組み込みました。その時の備忘録です。
※「エラーを出さずに動くようにする」をメインに進めていったので、「こっちの方がいい」「これやらない方がいい」等もあるかもです。適宜読み替えて実施してください。
手順 mermaidのUNPKGから、mermaild.min.jsとmermaild.min.js.mapをダウンロードする static/jsあたりに取得した2つのファイルを置く 適宜リネームしてください。私はVersion情報を入れてmermaild.min.9.2.jsにしました layouts/shortcodes/mermaid.htmlを作成する。 &amp;lt;script src=&amp;#34;{{&amp;#34;js/mermaid.min.9.2.js&amp;#34; | relURL}}&amp;#34; defer&amp;gt;&amp;lt;/script&amp;gt; &amp;lt;div class=&amp;#34;mermaid&amp;#34; align=&amp;#34;{{ if .Get &amp;#34;align&amp;#34; }}{{ .Get &amp;#34;align&amp;#34; }}{{ else }}center{{ end }}&amp;#34;&amp;gt; {{ safeHTML .Inner }} &amp;lt;/div&amp;gt; (ローカルで確認するときは)ビルド＆devサーバ立ち上げ 記事内に{{&amp;lt;mermaid&amp;gt;}} mermaidの記述 {{&amp;lt; /mermaid &amp;gt;}}と記述することで、図として表示されるようになります。 結果 これは試しに入れてみた公式ドキュメントの例:
(ダークモードだとちょっと見づらいかも)
sequenceDiagram participant Alice participant Bob Alice-&gt;&gt;John: Hello John, how are you? loop Healthcheck John-&gt;&gt;John: Fight against hypochondria end Note right of John: Rational thoughts prevail! John--&gt;&gt;Alice: Great! John-&gt;&gt;Bob: How about you?</description>
    </item>
    
    <item>
      <title>VSCodeで開いているファイルをgithubで表示する</title>
      <link>https://SawaTszm.github.io/post/get-code-url-viewing-in-vscode/</link>
      <pubDate>Wed, 02 Nov 2022 11:27:17 +0900</pubDate>
      
      <guid>https://SawaTszm.github.io/post/get-code-url-viewing-in-vscode/</guid>
      <description>前置き 今更何を言っているんだ感が凄まじいんですが、最近「ここ見たらわかりやすいですよ」とファイルのURL（できればgithub上の）を投げたい事があって、VScodeでファイル探す→githubのURLに直して渡すの流れが億劫だった（絶対VSCode上で出来るだろうにその時テンパってて見つけられなかった）のを真面目に探したら数分で発見したので備忘録として書いておきます。
結論 拡張機能：GitLensのコマンドで出来ます。
GitLens: Open File on Remote # ブラウザで開く GitLens: Copy Remote File Url # URLコピーする(便利) コマンドを実行する前に範囲選択しておくと、その行が選択された状態のURLになります。便利だ……。
反省 「不便だな」と思ったことを手数で誤魔化してそのままにしないこと。</description>
    </item>
    
    <item>
      <title>日記 2022-09-15</title>
      <link>https://SawaTszm.github.io/post/diary-2022-09-15/</link>
      <pubDate>Thu, 15 Sep 2022 21:36:09 +0900</pubDate>
      
      <guid>https://SawaTszm.github.io/post/diary-2022-09-15/</guid>
      <description>体調悪くてお休みいただいて、夜になってやっと復活してきたので、前記事(lodash is dead, long live radash)を見かけて気になってたRadashについて調べてました。
Radash - github
だけど調べてたら この「Lodashは死んだ」の記事と公式のドキュメント、githubページ以外全然関連の記事が出てこなくて（Radashって検索欄に入れてるのにRedashの記事ばっかり出てきて、マイナス検索してもRadashに触れてる記事はなかった）、記事は結構見られてたけどな……？と思って記事に戻ってみたら、書いてるのが作者本人でした。
(最後の方に書いてあったし、早い段階でGithubページ見に行ってリポジトリ名チェックしてたらもっと早く気づけたかもしれません)
タイトルだけ読んで現行のlodashに取ってかわる最新版なんだと思ってしまっていたので、この事実＆それ自体に気づくまでが結構長かったのが個人的なショックでした。そういう意味ではいい学びになった感じがします。
あと、コメント欄で「自分で書いとるんか〜い」みたいな突っ込みもされてましたが、それらに対して「それでもこのライブラリを作った彼の労力は賞賛すべき」「このような肯定的な批判を受け取る場を自ら作り出すこと自体に批判的になってはいけない。それはOSSの衰退につながる」みたいなコメントが多かったことも、OSS文化に触れてまだ浅い身からすると新しい気づきでした。
次からは、何かしら記事を見るときは「どういう立場で書かれているものか」は軽くチェックすることを心がけようと思います。</description>
    </item>
    
    <item>
      <title>TOEICを受けてきました</title>
      <link>https://SawaTszm.github.io/post/diary-2022-09-13/</link>
      <pubDate>Tue, 13 Sep 2022 19:07:16 +0900</pubDate>
      
      <guid>https://SawaTszm.github.io/post/diary-2022-09-13/</guid>
      <description>タイトル通りTOEIC受けてきました。
新卒時代にIPテストを受けて驚異の300点台前半を叩き出してから一回も受けてなかったんですが、最近英語圏のVtuberにハマって英語に触れる機会が増えてきたのでいけるのでは……？と思って勢いで申し込みました。
一応1ヶ月間は真面目に勉強したので、過去最高点は取れるんじゃないかなと思います（低すぎるハードル）。
以下備忘録を兼ねた感想です。
腕時計必須（それはそう） スマートウォッチ系がダメだって言うのを前日の夜に知って、腕時計なしで挑むことになったのが辛かったです。
1問20秒ほどだっていうのは知ってたので何とか体内時計で頑張りました。最後の問題解いたあたりで試験が終わったので、結構正確だったんだと思います（そこじゃない）。
今後も年1くらいで受けたいな〜と思ってるのでお気に入りの腕時計探しておきます。
慣れてないと集中力続けさせるのが結構キツい リスニングのPart4の途中と、リーディングのPart7の途中で「もう残り全部塗りつぶして帰りたいな……」ってなってました。
勉強してはいたんですが、一問一答形式のものをずっとやっていただけだったので、本番の長さに全く体が適応できてなかったです。
模試とか絶対やった方がいい。
勉強してる時ほど音声はクリアじゃない ノイキャン付きのイヤホンつけて聞く音源とやたらデカい室内のスピーカーの音は全然違うので、最初の音量合わせの時に慣れるのにもうちょっとフォーカス当てた方がいいなと思いました。
成長はちょっと感じた IP受けた時（3~4年前……？）は正直「問題に何聞かれてるかわからない」レベルだったのが、少なくともそこで困ることはなかったのでちょっとは成長してるんだな〜って感じました。
1ヶ月くらいで結果出ると思うので楽しみです。
追記 結果が出ました。初めて400点代が取れました＆今までの最高得点から100点近く上がりました！
点数的にはまだまだですが、この調子でこれからも頑張っていきたいです。</description>
    </item>
    
    <item>
      <title>日記(2022/06/25)</title>
      <link>https://SawaTszm.github.io/post/diary-2022-06-25/</link>
      <pubDate>Sat, 25 Jun 2022 13:08:08 +0900</pubDate>
      
      <guid>https://SawaTszm.github.io/post/diary-2022-06-25/</guid>
      <description>今更だけど remについて。
一回調べてなるほど〜！ってなった記憶はあるのにロジック考えずに見た目で数字決めてコミットしたの中々にテンパってたなって反省をした備忘録です。（一息）
remとは 基準のフォントサイズを1として考える単位。
例えば：1rem=16px(html要素のフォントサイズが16px)の場合、
12px: 0.75rem 14px: 0.875rem 18px: 1.125rem &amp;hellip; と言う感じ。
「〇〇pxって何remだっけ……」ってなって他のコードと実際の表示を見にいくことが多かったんですが、
欲しいpx数/ルートのフォントサイズ(px)すれば出てくる……出てくるのに……何で今まで調べなきゃ出てこないって思ってたんだろう……。
反省。次からは間違えないと思います。</description>
    </item>
    
    <item>
      <title>気をつけるべきだなと思ったこと</title>
      <link>https://SawaTszm.github.io/post/things-to-watch-out-for/</link>
      <pubDate>Thu, 23 Jun 2022 21:29:26 +0900</pubDate>
      
      <guid>https://SawaTszm.github.io/post/things-to-watch-out-for/</guid>
      <description>タイトルの通り、
最近仕事をしていて気がついたこと/教えてもらえたことで、自分はこれを気をつけた方がいいなと思ったことを忘れないために言語化したメモです。
(増えるかもしれません)
「既存のもの」を「覆してはならない前提」と捉えない 悪かった例(この場合はDjango) 私「このmodelにカラム追加したいけど、似たようなカラムがあるしな。データ被るのも嫌だから、propertyメソッドで動的に返すようにしよう」
~30分後~
「あ、propertyだとunion()時ののcolumn数合わせに使えないんだった。どうしよう……」(ここで無限ググり編に突入)
~30分後~
「クエリもうひとつ発行してitertools.chain()で繋げる手があるかぁ」(そうじゃない)
この時の結論：
元のmodelのデータ定義自体が改善しても良い範囲だったので、unionできる形にmodelを寄せることを提案してもらって解決しました。
メタ的な原因 既にプロジェクトに存在しているコードを、無意識に「絶対的に正しいもの」「変えちゃいけないもの」として捉えていました。
（「このmodelはこういう定義なんだから、これを変形してどうにかしないと」と言うところから思考がスタートしていた）
社会人初の案件がガチガチに要件が固まった後のネットワーク更改案件だったので、「既存のconfigは絶対に正しい、これを崩さないように新しい経路繋げないと」的な考えが根底に残ってたのかもしれないです。
(今までも似たような感覚に陥ったことが何回かあって、言語化できてちょっとスッキリしました)
改善策 「既存のもの」を「覆してはならない前提」と捉えない。 実装のために考え始める時、「そもそも」の疑問を大切にする。 「そもそも、どうしてこのmodelってこういう構造になったんだろう？」 言っても「考える時に気をつけよう」は忘れるので、しばらくモニターに付箋を貼る。 緊張時に毎回心拍数120近くまで上がるのはいき過ぎなので対策を考えるべき これ、最近調べて初めて知りました。
今まで緊張してる時(例えばプレゼン前とか、極端な例で言うと広めのメンションでslack送る前とか)Apple Watchに「非常に高い心拍数です」って言われるのをネタにして生きてきてたんですが、最近動悸が激しすぎて頭が真っ白になる経験をして、これはまずいなと思って調べたらやっぱり心拍数上がりすぎらしいです。
幸いその時は人前で喋るとかじゃなくて、家の中で一人ぜーはー言ってただけで落ち着く時間もあって事なきを得ましたが、このままじゃ良くないので色々対策してみようと思いました。</description>
    </item>
    
    <item>
      <title>[TIL] display: contents;</title>
      <link>https://SawaTszm.github.io/post/css-display-contents/</link>
      <pubDate>Mon, 20 Jun 2022 19:54:19 +0900</pubDate>
      
      <guid>https://SawaTszm.github.io/post/css-display-contents/</guid>
      <description>上手くいかないCSSをdev toolでぐりぐり動かしていたらdisplay: contents;なる値があることを知って、結局そのパターンは上手くいったんですがなんで上手くいったかわからないのでちょっとだけ調べました。
(本格的に調べるのは後日)
display: contents;とは colissで紹介されていました。
(先日参加した勉強会で紹介されていたサイトなのでちょっとテンションが上が理ました)
すごくざっくり言うと、
タグ内のコンテンツを通常通り描画しつつ、周囲のタグは完全に省略する display: contents; が指定されたタグ自体が無視されたような挙動になる CSS Gridのレイアウトで、複数あるカードのそれぞれの高さや幅を揃えるのに便利 (今回上手くいった修正はこのパターンだった) まだ全然追いきてれないですが、タグを無視したような挙動をする以上落とし穴(何かの拍子にめちゃくちゃ表示崩れる)とかもありそうなので、見れる時にもう少しちゃんと挙動を見たい……。
ちなみにCan I Useで見てみると、大体2018年くらいからパーシャルサポートが始まり、現在(2022/06)主要なブラウザはほとんどがフルサポートです。
IE君はNot Supportedですが先日卒業式をしたので……
参考 [CSS]「display: contents;」がすごい便利！ラッパーを使った実装が大きく変わるこれからのテクニック Can I use display: contents </description>
    </item>
    
    <item>
      <title>基本情報に受かりました</title>
      <link>https://SawaTszm.github.io/post/diary-2021-05-16/</link>
      <pubDate>Mon, 16 May 2022 21:41:51 +0900</pubDate>
      
      <guid>https://SawaTszm.github.io/post/diary-2021-05-16/</guid>
      <description>タイトルの通り 3月頃に思い立って申し込みをして、1ヶ月前後の勉強で受かりました。嬉しいことに午前午後どちらも9割近く取った上での合格でした。
全体的には、学生時代に学んだことを思い出すのに役立ったなぁと言う印象でした。
学生の頃に「ITパスポート取るか。言っても専攻だし(情報工学科だった)いけるでしょ！」と全く勉強をせずに行って落ちた経験があり、国家試験系からは長年目を背け続けていたので、受けるにあたってちょっと驚いたことがいくつかあったので書いておきます。
早起きを証明できる試験ではなくなっていた よく基本情報についてTwitterなどで「朝早く起きて会場に行ける社会性を証明できる試験」なんて揶揄されているのを目にしていましたが、CBT方式になって時間は選び放題、なんなら午前と午後を別日に受けてもいいと言う緩さになっていました。
正直、今回基本情報を実際に受ける気になったのも、このCBT方式で受けられると言うのを知ったから、と言うところが大きかったです。
直近の過去問が参照できない 基本情報と言えば引くほど過去問が見れるイメージがあったんですが、CBT方式になってからの過去問は公開されていないみたいです。
今はまだCBT方式になってから日が浅い＆シラバスの大幅な改訂も入っていないので、公開されている過去問を一通り解いても十分勉強になります。ただ、これからどんどん過去問と実際の問題との乖離が進んでいくんじゃないかなーと思います。
(そもそもCBT方式にしてから合格者の割合がグッと増えてるらしいので、そう言う意味ではちょうど良いところに落ち着くのかも？)
応用情報はまだ紙試験 この勢いで応用情報も受けようかな〜と思ったんですが、応用情報の方はまだ筆記らしくて悩んでます。
朝起きれないし、一日に午前午後で集中力続く気がしないので……(社会適応力皆無)。</description>
    </item>
    
    <item>
      <title>docker for Macが更新できない</title>
      <link>https://SawaTszm.github.io/post/docker-for-mac-does-not-work/</link>
      <pubDate>Mon, 10 Jan 2022 12:45:25 +0900</pubDate>
      
      <guid>https://SawaTszm.github.io/post/docker-for-mac-does-not-work/</guid>
      <description>環境 PC: macbook Air (M1) OS: Big Sur 11.6.1 起きた問題 ある日、docker desktop for macのアイコンからPreferencesを押してもDockerの画面が立ち上がらなくなりました(アイコンが2,3回跳ねて落ちる)。
同様にDownload updateも立ち上がらないのでおや？と思い、一度PCを再起動したらFatal Error Failed to ping backend APIというエラーウィンドウが出てdocker自体が立ち上がらなくなりました。
Reset Docker to factory defaults, Diagnose &amp;amp; Feedback, Exitの選択肢はありますが押せない（カーソルぐるぐる）状態になっていて、リセットもさせてくれません。
どうやら似た状況になっている方も結構いるようで、既知のバグ？のようです。(docker for macのissue)。こちらでも未だに議論されていて、完璧な解決策はまだ出ていないように見えます。
色々参考にさせてもらいつつとりあえず復旧はさせたので、手順を残しておこうと思います。
復帰方法 docker関連のプロセスをkillする コマンドで消すか、アクティビティモニタでdockerを調べて出てきたものを終了させます。
# コマンドの場合 $killall Docker アンインストール アプリケーションフォルダからゴミ箱にどん。今思えばもうちょっとスマートなやりようがあった気がします。
新しいのをインストールする 公式サイトから最新版をダウンロード＆インストール。
フルアクセスを許可 上記でインストールしたものが上手く立ち上がればここはスキップしてもいいと思います（起動時にアクセス権限の変更をdocker側から提案してくれる筈なので）。
システム環境設定&amp;gt;セキュリティとプライバシー&amp;gt;フルディスクアクセスからdockerにフルアクセスを許可します。
（追記）
しばらく触っていなかった別のmacbookを見てみたらdockerにそんな権限は渡していなかった（でも上手く動いている）ので、ここに関してはちょっと不確かかも知れません。
docker再起動 うまく動きました。</description>
    </item>
    
    <item>
      <title>初めてのOSS Contribute【First Contributions編】</title>
      <link>https://SawaTszm.github.io/post/first-oss-contributions/</link>
      <pubDate>Wed, 05 Jan 2022 20:34:34 +0900</pubDate>
      
      <guid>https://SawaTszm.github.io/post/first-oss-contributions/</guid>
      <description>https://firstcontributions.github.io/
Make your first open source contribution in 5 minutes.
君も5分でOSSコントリビューターだ！(意訳)
「OSS活動への貢献してみたいけど、まずどうすれば良いのかよくわからないな」と思って調べていた時に発見した上記のありがたいプロジェクトで、OSSコントリビュータデビューさせてもらった時の備忘録です。
OSSにPR出してみたいけどぶっつけ本番は緊張する、貢献したいOSSとかまだあんまり決まってない(けどやりたいとは思ってる)人がもしいれば、このプロジェクトの胸を借りることをお勧めします。
流れのまとめ First ContributionsのリポジトリでPRを出す流れを体験させてもらう サイトのプロジェクトリストを参考に作業するリポジトリを探す ↑のREADMEやContribute.mdなどでルールを確認(大事) 1.の要領でPRを作成、修正、マージ PRの手順 基本的にはリポジトリのREADMEに沿って進めるだけです。5分もかかりませんでした。
(様々な言語で翻訳されていて、コミュニティの大きさを感じます)
簡単な手順は以下の通り。
リポジトリをフォーク フォークしたリポジトリをクローンしてくる ブランチを作成 コードを変更してコミット Push PRを送る(githubで自分のリポジトリに行くとCompare &amp;amp; pull requestボタンが表示される) これで完了です！
記念すべき人生初OSSコミットがこちら
練習が終わったら本番 PRを出すまでの流れを実際に体験できたので、いよいよ他のOSSにPR出していくぞ！という流れなのですが、貢献したいコミュニティが最初から決まっている場合を除くとどこのリポジトリにどういう作業をさせてもらおうか悩む、というか目星をつけられなくて困ると思います。少なくとも私は困りました。
ですがその辺りもFirst Contributionsはカバーしてくれていて、ネクストステップとして取り組みやすいプロジェクトのリストを用意してくれています。(一番最初に貼ったURLと同じです)
https://firstcontributions.github.io/
ここで自分で使っている言語や諸々で絞り込んで、気になったリポジトリのissue等を見ていくと、すぐに取り組めるタスクがあったりします。
(もしくは実際に使ってみて、気になる箇所があればissueやそれに対するPRを立てたりもできます)
私の場合は、興味があったリポジトリに誰でも取り組んで良い「ファイルごとのテストカバレッジを100%にする」issueが立っていたのでそれに着手しました。
大体のリポジトリはREADMEやContribute.mdなどに貢献の方法やルールが明記されているのでまずはそれを見て、しっかりそれらを守りつつ作業することを心がけましょう(自戒)。
記念すべき人生二度目OSSコミットがこちら
余談 OSSコントリビューションというと花形のPRに目が行きがちですが、issueでのエラー報告も立派な貢献になるみたいです。言われてみれば確かに、実装中エラーに当たった時OSSのissueにはいつもお世話になってます。 カタカナ表記の場合、リポジトリ派閥とレポジトリ派閥があることに気がつきました。IT用語辞典などでも併記されているので、完全に好みの問題みたいです。 軽い気持ちでやったFirst Contributionsさんのお試しPRでしたが、大きな声では言えないですがこれひとつでfindyさんの偏差値が結構上がりました（！）。OSSへの貢献はエンジニアのハードルの一つなのかも知れないですね。 </description>
    </item>
    
    <item>
      <title>2021 08 05 Diary</title>
      <link>https://SawaTszm.github.io/post/diary-2021-08-05/</link>
      <pubDate>Thu, 05 Aug 2021 21:26:58 +0900</pubDate>
      
      <guid>https://SawaTszm.github.io/post/diary-2021-08-05/</guid>
      <description>最近やったこと DIY(初級) 人生初DIYで元々使ってた机をL字に改造しました。
加工済みのいい感じのサイズの板買ってきてネジで止めただけの簡易机ながら結構快適。仕事も趣味も机に向かってやる系でオンオフの切り替え(というか机片付けてPCしまってiPad出して……の一連の作業)が面倒くさくて困ってたから、趣味の環境をL字の部分にそのまま広げて置くことで凄く楽になりました。
ブログ(ここ)の改装 見た目を若干弄りました。
HTML, CSSに苦手意識を持っててあんまり積極的に触ってこなかったけど(仕事で必要な時にリファレンス見ればいいやの精神)、色々教えてもらってソース見たり弄ったりするのが楽しくなってきました。
そのうちHUGOのテーマ作りたいですね。
気になったもの crowdin crowdin - Agile localization for tech companies
最近買ったDjango本で紹介されてたDjango Girlsのチュートリアル内で、翻訳を進めていくために使われてました。
Django Girlsのチュートリアル Django Girls(上とダブるけど)
さっと見たけどめちゃくちゃわかりやすかったです。特にインターネットの仕組みあたり。
人に教える機会があったらここおすすめしたいです。
その他 新すばせかが楽しいです。指は死んでます。</description>
    </item>
    
    <item>
      <title>【Python】フォーマット済み文字列リテラル</title>
      <link>https://SawaTszm.github.io/post/python-%E3%83%95%E3%82%A9%E3%83%BC%E3%83%9E%E3%83%83%E3%83%88%E6%B8%88%E3%81%BF%E6%96%87%E5%AD%97%E5%88%97%E3%83%AA%E3%83%86%E3%83%A9%E3%83%AB/</link>
      <pubDate>Mon, 02 Aug 2021 18:52:08 +0900</pubDate>
      
      <guid>https://SawaTszm.github.io/post/python-%E3%83%95%E3%82%A9%E3%83%BC%E3%83%9E%E3%83%83%E3%83%88%E6%B8%88%E3%81%BF%E6%96%87%E5%AD%97%E5%88%97%E3%83%AA%E3%83%86%E3%83%A9%E3%83%AB/</guid>
      <description>目的 すごく今更&amp;amp;簡潔にだけど、python3.6以降で利用できる文字列フォーマットについてまとめていきます。
（ずっとstr.format()を使っていたので戒めも兼ねて）。
フォーマット済み文字列リテラルとは フォーマット済み文字列リテラル(f-string)では、文字列の先頭にfを付けることで、pythonの式を文字列内に{式}の形で埋め込むことができます。
従来の書き方よりも簡潔、かつわかりやすく記述することができる書き方です。
公式ドキュメント
使い方 変数に入った数字を3文字のカンマ区切りにする hoge = 99999999 # 従来のstr.format() print(&amp;#34;{:,}&amp;#34;.format(hoge)) # フォーマット済み文字列リテラル print(f&amp;#34;{hoge:,d}&amp;#34;) :の後ろに整数をつけて縦を揃える tokuten = {&amp;#34;kokugo&amp;#34;: 9, &amp;#34;sugaku&amp;#34;: 81, &amp;#34;eigo&amp;#34;: 100} for sub, point in tokuten.items(): print(f&amp;#39;{sub:10} ==&amp;gt; {point:5d}&amp;#39;) # kokugo ==&amp;gt; 9 # sugaku ==&amp;gt; 81 # eigo ==&amp;gt; 100 まとめ 従来のstr.format()と比べると、f-stringは最終結果が人の目で見てもわかりやすいですね。</description>
    </item>
    
    <item>
      <title>Lodashの概要と関数まとめ</title>
      <link>https://SawaTszm.github.io/post/javascript-lodash/</link>
      <pubDate>Sat, 17 Jul 2021 11:11:15 +0900</pubDate>
      
      <guid>https://SawaTszm.github.io/post/javascript-lodash/</guid>
      <description>lodashとは The Lodash library exported as a UMD module.
(中略) &amp;hellip;Lodash makes JavaScript easier by taking the hassle out of working with arrays, numbers, objects, strings, etc.
配列、数値、オブジェクト、文字列など、値を扱う際に便利な関数を多く提供しているJavaspriptのライブラリです。
_.getや_.eachなどがそれ。
公式ドキュメントがすごくわかりやすくていい感じです。
lodash - github
公式ドキュメント
使い方 インポート import _ from &amp;#39;lodash&amp;#39;; 関数 _.get() _.get(object, path, [defaultValue]) objectのpathの値を取得する。値を解決できなかった場合、defaultValueを返す。
_.has() _.has(object, path) objectのpathの値が存在するかを調べる。値自体は返さない。
_.set() _.set(object, path, value) objectのpathにvalueの値をセットする。
pathが定義されていない場合は新しく作られる。
インデックスのプロパティがない場合は配列が作成され、それ以外のプロパティがない場合はオブジェクトが作成される。(？)
_.each() -&amp;gt; forEach() _.forEach(collection, [iteratee=_.identity]) collectionの要素を反復し、各要素に対してiterateeを実行。
iterateeは3つの引数(value, index|key, collection)で呼び出される。
※iteratee関数は明示的にfalseを返すことで反復を終わらせることができる
_.flatten() _.flatten(array) arrayを一段分フラットにする。非破壊的メソッド。</description>
    </item>
    
    <item>
      <title>【AWS SAM】テンプレートでCloudWatchイベントを記述する</title>
      <link>https://SawaTszm.github.io/post/aws-sam-template/</link>
      <pubDate>Fri, 19 Feb 2021 12:01:46 +0900</pubDate>
      
      <guid>https://SawaTszm.github.io/post/aws-sam-template/</guid>
      <description>目的 バッチ処理もAWS Lambdaで書きたいので、SAM テンプレートに記述できるのかどうかを調べたい。
結論 できます。
し、かなりわかりやすいです。
CloudWatch イベント アプリケーションの AWS SAM テンプレート
記述例 AWSTemplateFormatVersion: &amp;#34;2010-09-09&amp;#34; Transform: AWS::Serverless-2016-10-31 Globals: Function: Timeout: 30 MemorySize: 256 Handler: app.lambda_handler Runtime: python3.7 Resources: ### Batch ### HogeBatchFunction: Type: AWS::Serverless::Function Properties: CodeUri: api/batch/hoge_batch Events: HogeBatch: # TypeをScheduleに Type: Schedule Properties: # 実行タイミングを決める Schedule: cron(0 0 ? * SUN *) 最後のSchedule式は、rateとcronのどちらでも使えます。
Rate または Cron を使用したスケジュール式
参考 ざっと見て参考にさせてもらいたいなと思った記事(と公式ドキュメント):
What Is the AWS Serverless Application Model (AWS SAM)?</description>
    </item>
    
    <item>
      <title>【DDD】前提知識まとめ</title>
      <link>https://SawaTszm.github.io/post/ddd-%E5%89%8D%E6%8F%90%E7%9F%A5%E8%AD%98%E3%81%BE%E3%81%A8%E3%82%81/</link>
      <pubDate>Fri, 19 Feb 2021 12:01:46 +0900</pubDate>
      
      <guid>https://SawaTszm.github.io/post/ddd-%E5%89%8D%E6%8F%90%E7%9F%A5%E8%AD%98%E3%81%BE%E3%81%A8%E3%82%81/</guid>
      <description>目的 社内お勉強会で DDD 本を輪読することになったんですが、
改めて「〇〇ってわかりますか？」と言われると戸惑ってしまうことが多いので自分用にまとめました。
抽象クラス(abstract class) 他のクラスで継承してもらうことを前提としたクラス。
複数のクラスの共通処理の中に、一部異なる処理を使用したい場合などに定義する。
抽象クラス自体はインスタンス化できない abstract functionで抽象メソッドを定義できる インターフェース クラスが実装するメソッドを定義することができるもの。
メソッドの実体は持てない(定義のみ) 使用できる修飾子はpublicのみ 定数を持てる。実装先のクラスでのオーバーライドはできない
不特定のクラスで、共通のメソッドを定義したい場合などに定義する。 ポリモーフィズム 「中に入るものによって、同じ関数でも違う処理を行える」というオブジェクト指向プログラミングの特徴のこと。
「モノが「そのモノ」らしく振る舞うこと」 =「呼び出した関数が、呼び出し元のオブジェクトに適した振る舞いをすること」
# 動物は必ず「鳴く」 interface Animal { sound(); } # 犬は「動物らしい振る舞い」をする(鳴く) class dog implements Animal { sound() { /**/ } } # 動物は「鳴く」ので、引数の動物ごとの異なる鳴き声を処理する # 引数で与えられる動物によって、異なる処理(鳴き声)ができる public function animalsound(animal) { animal.sound() } 継承 親クラスの振る舞いを引き継いで、子クラスを実装すること。 子クラス側で親クラスを拡張することができる。
委譲 実際の振る舞いを別のオブジェクトに委ねることで、別のオブジェクトの振る舞いを再利用する手法。(？)
カプセル化 関連のあるデータとその使い方を一まとめにしたもの。 内部のデータを直接いじることはさせずに、使い方だけを見せる。
GoF デザインパターン 23 種類あるヤツ(雑)
勉強します
3 分でわかるデザインパターン入門
SOLID 原則 SOLID 原則とは Robert C.</description>
    </item>
    
    <item>
      <title>【Docker】【nginx】docker-compose上のnginxをhttps対応する(開発環境編)</title>
      <link>https://SawaTszm.github.io/post/docker-nginx-ssl-on-server/</link>
      <pubDate>Fri, 19 Feb 2021 12:01:46 +0900</pubDate>
      
      <guid>https://SawaTszm.github.io/post/docker-nginx-ssl-on-server/</guid>
      <description>目的 docker-composeで立てたnginxをhttps対応にしたい。
あくまでも開発環境用なのでオレオレ証明書です。
手順 自己署名証明書をサクッと作成する ❯ openssl req -x509 -nodes -new -keyout server.key -out server.crt -days 365 docker-composeの更新 443ポートを使用するように変更。
また、作成した証明書も読み込めるようにvolumesも更新。
version: &amp;#34;3.5&amp;#34; services: web: build: ./docker/nginx restart: always ports: - 443:443 # 変更 depends_on: - app volumes: - ./:/var/www/html - ./docker/nginx/default.conf:/etc/nginx/conf.d/default.conf - ./docker/nginx/server.crt:/etc/nginx/server.crt # 追加 - ./docker/nginx/server.key:/etc/nginx/server.key # 追加 links: - app networks: - default default.confの更新 ポートを443に変更し、証明書の情報を追加します。
server { listen 443; ssl on; ssl_certificate /etc/nginx/server.crt; ssl_certificate_key /etc/nginx/server.key; index index.php index.html; server_name php-docker.</description>
    </item>
    
    <item>
      <title>【Embulk】インストール＆dynamoDBのインポートを試してみる</title>
      <link>https://SawaTszm.github.io/post/embulk-install-and-dynamodb-import/</link>
      <pubDate>Fri, 19 Feb 2021 12:01:46 +0900</pubDate>
      
      <guid>https://SawaTszm.github.io/post/embulk-install-and-dynamodb-import/</guid>
      <description>割と大量のデータを別の場所に転送したい。といった要件があり、諸々模索している最中で、先輩から教えてもらったEmbulkを触ってみたのでまとめました。
Embulkとは GitHub - embulk/embulk: Embulk: Pluggable Bulk Data Loader.
さまざまなストレージ、データベース、NoSQL、クラウドサービス間のデータ転送を支援する並列バルクデータローダーです。
関数を追加するプラグインをサポートしており、インプット先/アウトプット先に沿ったプラグインを適宜使用する/作成することで、前述の様々なストレージやDBなどでデータ転送を行うことができます。
インストール Brewでインストール可能です。
$ brew install embulk # embulk: Java 1.8 is required to install this formula. と言われたらエラー文通り下記でJava入れてもう一回 $ brew cask install homebrew/cask-versions/adoptopenjdk8 必要だなと思ったプラグインをプラグイン一覧から確認してインストール。
# CSVインポート $ embulk gem install embulk-input-jdbc # mysqlインポート $ embulk gem install embulk-input-mysql # mysqlアウトプット $ embulk gem install embulk-output-mysql # などなど チュートリアル 公式ドキュメントに乗っている、めちゃくちゃ簡単な動作確認チュートリアルです。
CSVを読み込んで画面に表示するだけの簡単なものになっています。
# サンプルCSVファイル、構成ファイルを作成 $ embulk example ./try1 # 推測プラグインを呼び出して適切な構成ファイル(提案)を出力。 $ embulk guess .</description>
    </item>
    
    <item>
      <title>【laravel-admin】インストール＆画面作成まで 編</title>
      <link>https://SawaTszm.github.io/post/laravel-admin-install/</link>
      <pubDate>Fri, 19 Feb 2021 12:01:46 +0900</pubDate>
      
      <guid>https://SawaTszm.github.io/post/laravel-admin-install/</guid>
      <description>目的 ここ最近、しばらくlaravel-adminという管理画面を作成するためのライブラリを使っていたので、調べたことやつまづいたところも含めて少しずつ書き起こそうと思います。
まずはインストール編です。簡単に管理画面を確認できるところまで見ていきましょう。
laravel-adminとは laravelで簡単にDBの管理画面を作成することができるライブラリです。
ドキュメントやデモサイトなど使用するために必要な資料が充実しており、難しいカスタムを行う必要がなければものすごく簡単に管理画面が構築できます。
Laravel-admin(ドキュメント)
GitHubページ
基本的な使用方法は上記でカバーし、カスタマイズして使用したい際には直接ソースコードを読んで適宜書き換えていく形になります。
主観ですが、コード内のコメントも(おそらく書き換える前提の部分は)丁寧に書かれているので、しっかり読み解けば問題ないかと思います。
プロジェクトの作成 既に開発しているlaravelプロジェクトに追加する場合は、この章は飛ばしてもらって大丈夫です。
何もないところからlaravel-adminを試したい方は、まずlaravelプロジェクトを作成するところから始めましょう。
公式によると、現在のバージョンでは以下の環境が推奨されるようです。
PHP 7+ laravel 5.5+ This package requires PHP 7+ and Laravel 5.5, for old versions please refer to 1.4
laravel-admin install
$composer create-project --prefer-dist &amp;#34;laravel/laravel=5.5.*&amp;#34; &amp;lt;project-name&amp;gt; DBも必要になってくるので、.envにDBの情報も書き足しておきましょう。
よければこちらの記事も参考にしてみてください。
【Laravel+MySQL+nginx】docker-composeで最小構成の環境構築 - SawaLog
インストール laravelの準備ができたら早速laravel-adminをインストールします。
$composer require encore/laravel-admin インストールが終わったら下記コマンドを実行します。
$php artisan vendor:publish --provider=&amp;#34;Encore\Admin\AdminServiceProvider&amp;#34; $php artisan admin:install これらを実行すると、app/Adminディレクトリが作られます。これからの実装はこのディレクトリ配下で行うことになります。
ファイルの初期配置は以下。
app/Admin ├── Controllers │ ├── ExampleController.php │ └── HomeController.php ├── bootstrap.</description>
    </item>
    
    <item>
      <title>【Laravel】Laravelで使用するDBををReadWrite構成にする時の確認でちょっとハマった話</title>
      <link>https://SawaTszm.github.io/post/laravel%E3%81%A7%E4%BD%BF%E7%94%A8%E3%81%99%E3%82%8Bdb%E3%82%92%E3%82%92readwrite%E6%A7%8B%E6%88%90%E3%81%AB%E3%81%99%E3%82%8B%E6%99%82%E3%81%AB%E3%81%A1%E3%82%87%E3%81%A3%E3%81%A8%E3%83%8F%E3%83%9E%E3%81%A3%E3%81%9F%E8%A9%B1/</link>
      <pubDate>Fri, 19 Feb 2021 12:01:46 +0900</pubDate>
      
      <guid>https://SawaTszm.github.io/post/laravel%E3%81%A7%E4%BD%BF%E7%94%A8%E3%81%99%E3%82%8Bdb%E3%82%92%E3%82%92readwrite%E6%A7%8B%E6%88%90%E3%81%AB%E3%81%99%E3%82%8B%E6%99%82%E3%81%AB%E3%81%A1%E3%82%87%E3%81%A3%E3%81%A8%E3%83%8F%E3%83%9E%E3%81%A3%E3%81%9F%E8%A9%B1/</guid>
      <description>起こった問題 タイトルの通り、Laravelで使用するDBのhostをRead/Weiteで切り替えたい、と思って設定をしていました。
設定後下記を確認して、
&amp;gt;&amp;gt;&amp;gt; config(&amp;#39;database.connections.pgsql&amp;#39;) =&amp;gt; [ &amp;#34;read&amp;#34; =&amp;gt; [ &amp;#34;host&amp;#34; =&amp;gt; [ &amp;#34;postgres2&amp;#34;, ], ], &amp;#34;write&amp;#34; =&amp;gt; [ &amp;#34;host&amp;#34; =&amp;gt; &amp;#34;postgres&amp;#34;, ], ... 反映されてるな、と思って念の為connectionも見てみました。
&amp;gt;&amp;gt;&amp;gt; DB::connection(&amp;#39;pgsql::read&amp;#39;)-&amp;gt;getConfig(); =&amp;gt; [ ..., &amp;#34;host&amp;#34; =&amp;gt; &amp;#34;postgres&amp;#34;, ] ……あれ？
Readコネクションなのでpostgres2であって欲しいのに、postgresが出てきてしまいました。
反映されてないのかな？と思い色々調べたので、備忘録として置いて起きます。
調べたこと getConfigで参照されるconfigは、
Illuminate\Database\Connectors\ConnectionFactory::make内で、
/** * Establish a PDO connection based on the configuration. * * @param array $config * @param string|null $name * @return \Illuminate\Database\Connection */ public function make(array $config, $name = null) { $config = $this-&amp;gt;parseConfig($config, $name); if (isset($config[&amp;#39;read&amp;#39;])) { return $this-&amp;gt;createReadWriteConnection($config); } return $this-&amp;gt;createSingleConnection($config); } createReadWriteConnectionが呼び出され、</description>
    </item>
    
    <item>
      <title>【Laravel】フォームリクエストでのバリデーションに条件付きの制約を追加する</title>
      <link>https://SawaTszm.github.io/post/laravel-%E3%83%95%E3%82%A9%E3%83%BC%E3%83%A0%E3%83%AA%E3%82%AF%E3%82%A8%E3%82%B9%E3%83%88%E3%81%A7%E3%81%AE%E3%83%90%E3%83%AA%E3%83%87%E3%83%BC%E3%82%B7%E3%83%A7%E3%83%B3%E3%81%AB%E6%9D%A1%E4%BB%B6%E4%BB%98%E3%81%8D%E3%81%AE%E5%88%B6%E7%B4%84%E3%82%92%E8%BF%BD%E5%8A%A0%E3%81%99%E3%82%8B/</link>
      <pubDate>Fri, 19 Feb 2021 12:01:46 +0900</pubDate>
      
      <guid>https://SawaTszm.github.io/post/laravel-%E3%83%95%E3%82%A9%E3%83%BC%E3%83%A0%E3%83%AA%E3%82%AF%E3%82%A8%E3%82%B9%E3%83%88%E3%81%A7%E3%81%AE%E3%83%90%E3%83%AA%E3%83%87%E3%83%BC%E3%82%B7%E3%83%A7%E3%83%B3%E3%81%AB%E6%9D%A1%E4%BB%B6%E4%BB%98%E3%81%8D%E3%81%AE%E5%88%B6%E7%B4%84%E3%82%92%E8%BF%BD%E5%8A%A0%E3%81%99%E3%82%8B/</guid>
      <description>やりたいこと Laravel くんで Controller をすっきりさせたいので、バリデーションをフォームリクエストで行いたい。
プラスで、簡単な条件分岐のバリデーションも付け足したい。
結論 withValodatorメソッドを通してsometimesを使うのが良さげです。
詳しく 通常のフォームリクエストでのバリデーション // FormRequest namespace App\Http\Request; use \\illuminate\Foundation\Http\FormRequest; class ItemUpdateRequest extends FormRequest { /** * Determine if the user is authorized to make this request. * * @return bool */ public function authorize() { return true; } public function rules() { return [ &amp;#39;id&amp;#39; =&amp;gt; &amp;#39;required|integer&amp;#39;, &amp;#39;item_type&amp;#39; =&amp;gt; &amp;#39;required|string|in:tv,web,radio&amp;#39; &amp;#39;name&amp;#39; =&amp;gt; &amp;#39;required|string|max:255&amp;#39;, &amp;#39;url&amp;#39; =&amp;gt; &amp;#39;nullable|url|max:2083, &amp;#39;note&amp;#39; =&amp;gt; &amp;#39;nullable|string|max:2047&amp;#39;, ]; } } // Controller(必要な記述以外は省略) use App\Http\Request\ItemUpdateRequest; class ItemController extends Controller { public function update(ItemUpdateRequest $request) { // } } これだけで通常のバリデーションは出来ますね。</description>
    </item>
    
    <item>
      <title>【Laravel】独自ペジネータで自前のCollectionを使う</title>
      <link>https://SawaTszm.github.io/post/laravel-%E7%8B%AC%E8%87%AA%E3%83%9A%E3%82%B8%E3%83%8D%E3%83%BC%E3%82%BF%E3%81%A7%E8%87%AA%E5%89%8D%E3%81%AEcollection%E3%82%92%E4%BD%BF%E3%81%86/</link>
      <pubDate>Fri, 19 Feb 2021 12:01:46 +0900</pubDate>
      
      <guid>https://SawaTszm.github.io/post/laravel-%E7%8B%AC%E8%87%AA%E3%83%9A%E3%82%B8%E3%83%8D%E3%83%BC%E3%82%BF%E3%81%A7%E8%87%AA%E5%89%8D%E3%81%AEcollection%E3%82%92%E4%BD%BF%E3%81%86/</guid>
      <description>やりたいこと データベース：ペジネーション 5.8 Laravel
このページの「独自ペジネータ作成」の欄にあるように、
Illuminate\Pagination\LengthAwarePaginatorインスタンスを作成して、自前の Collection を Collection のままページネーションしたい。
結論 ペジネーションは引数に Collection を許容しているので実装が可能。
LengthAwarePaginatorインスタンスの第一引数に渡す Collection を、slice()メソッドを使って Collection の型を崩さずに区切る。
これだけ見ると「自明では？」と思うけど、初心者(私)はどハマりしたので過程も含めて書いておきます。
ハマった流れ まず「Eloquent ORM から取ってきた結果をページネーションしたいわね」と思い Laravel くんドキュメント(前述)を参照しました。
Note: 自前でペジネーターインスタンスを生成する場合、ペジネーターに渡す結果の配列を自分で”slice”する必要があります。その方法を思いつかなければ、 [array_slice] PHP 関数を調べてください。
なるほど！！！！！
と思い array_slice()を使用して記述したのが以下のような書き方。
// app/Services/ItemsService.php // 前略。$columnsには取得したいカラム名を格納 $items = ItemMaster::query() -&amp;gt;select($columns) -&amp;gt;with(&amp;#39;relatedUsers&amp;#39;) -&amp;gt;get(); // 表示する件数のみ取得するために、ページ番号($page)と最大表示件数($limit)から$offsetを計算 $offset = ($page * $limit) - $limit; // ドキュメントに言われたように表示する部分のみ切り取った配列を用意 $slice = array_slice($items-&amp;gt;toArray(), $offset, $limit); return new LengthAwarePaginator($slice, count($items), $limit, $page); これでも$columnsの値を参照する分には特に問題ありません。
ただ、return を受け取った先の Resource なんかでリレーションの情報が欲しくて$this-&amp;gt;relatedUsers.</description>
    </item>
    
    <item>
      <title>【Laravel&#43;MySQL&#43;nginx】docker-composeで最小構成の環境構築</title>
      <link>https://SawaTszm.github.io/post/laravel&#43;mysql&#43;nginx-docker-compose%E3%81%A7%E6%9C%80%E5%B0%8F%E6%A7%8B%E6%88%90%E3%81%AE%E7%92%B0%E5%A2%83%E6%A7%8B%E7%AF%89/</link>
      <pubDate>Fri, 19 Feb 2021 12:01:46 +0900</pubDate>
      
      <guid>https://SawaTszm.github.io/post/laravel&#43;mysql&#43;nginx-docker-compose%E3%81%A7%E6%9C%80%E5%B0%8F%E6%A7%8B%E6%88%90%E3%81%AE%E7%92%B0%E5%A2%83%E6%A7%8B%E7%AF%89/</guid>
      <description>目的 laravel-admin使いたいだけの用途にLaradockは重すぎる……
ので、お勉強も兼ねて、docker-composeでLaravel&amp;amp;MySQLのみの環境を立てました。
その上でlaravel-adminの管理画面まで開けるようにしてみます。
構成 project_root_dir ├── docker-compose.yml ├── docker │ ├── nginx │ │ ├── Dockerfile │ │ └── default.conf │ ├── php │ │ └── Dockerfile │ └── db │ │ ├── my.cnf │ └── Dockerfile └── laravel └── ... 手順 docker-compose.ymlを作成 # docker-compose.yml version: &amp;#34;3.5&amp;#34; services: app: build: context: . dockerfile: ./docker/php/Dockerfile args: PROJECT_NAME: app_admin volumes: - ./:/var/www/html depends_on: - database links: - database ports: - &amp;#34;4000:80&amp;#34; - &amp;#34;4001:8080&amp;#34; tty: true database: image: mysql:5.</description>
    </item>
    
    <item>
      <title>【MySQL】外部キー追加時にエラー</title>
      <link>https://SawaTszm.github.io/post/mysql-%E5%A4%96%E9%83%A8%E3%82%AD%E3%83%BC%E8%BF%BD%E5%8A%A0%E6%99%82%E3%81%AB%E3%82%A8%E3%83%A9%E3%83%BC/</link>
      <pubDate>Fri, 19 Feb 2021 12:01:46 +0900</pubDate>
      
      <guid>https://SawaTszm.github.io/post/mysql-%E5%A4%96%E9%83%A8%E3%82%AD%E3%83%BC%E8%BF%BD%E5%8A%A0%E6%99%82%E3%81%AB%E3%82%A8%E3%83%A9%E3%83%BC/</guid>
      <description>エラー 外部キー制約を追加しようとした時、下記エラーで怒られました。
ERROR 1215 (HY000): Cannot add foreign key constraint “外部キー制約を追加できません”
もっと詳細なエラーログが……ほしい……！ と思ったので調べました。
SHOW ENGINE INNODB STATUS で外部キー制約時のエラーを確認 恐らくとてつもなく初歩的な話だと思うのですが、SHOW ENGINE 構文なるものがあると。
SHOW ENGINE INNODB STATUS SHOW ENGINE INNODB STATUSは、InnoDBストレージエンジンの状態に関するInnoDB標準モニターからの広範囲にわたる情報を表示します。
MySQL :: MySQL 5.6 リファレンスマニュアル :: 13.7.5.16 SHOW ENGINE 構文
便利だ！！！！！
実践 早速入って見てみます。
$ docker exec -it [docker-name] bash # mysql -u [username] -p &amp;gt; SHOW ENGINE INNODB STATUS ------------------------ LATEST FOREIGN KEY ERROR ------------------------ Cannot find an index in the referenced table where the referenced columns appear as the first columns, or column types in the table and the referenced table do not match for constraint.</description>
    </item>
    
    <item>
      <title>【Python】cerberusまとめ</title>
      <link>https://SawaTszm.github.io/post/python-summary-of-cerberus/</link>
      <pubDate>Fri, 19 Feb 2021 12:01:46 +0900</pubDate>
      
      <guid>https://SawaTszm.github.io/post/python-summary-of-cerberus/</guid>
      <description>cerberusとは CERBERUS, n. The watch-dog of Hades, whose duty it was to guard the entrance; everybody, sooner or later, had to go there, and nobody wanted to carry off the entrance. - Ambrose Bierce, The Devil’s Dictionary
ケルベロスはシンプルで軽量なデータ検証機能を提供するパッケージです。
公式曰く、拡張も容易なため、カスタム検証も可能です。
(以下、9割公式のドキュメントの翻訳です)
概要 検証用のスキーマを定義し、それを Validator クラスのインスタンスに渡します。
schma = {&amp;#39;name&amp;#39;: {&amp;#39;type&amp;#39;: &amp;#39;string&amp;#39;}} v = Validator(schema) 次に、validate()を呼び出すことで、簡単にスキーマと辞書を検証できます。
検証が成功すると True が返されます。
document = {&amp;#39;name&amp;#39;: &amp;#39;john doe&amp;#39;} v.validate(document) # True インストール 安定バージョンはpipから取得できます。
pip install cerberus
使い方 基本的な使い方 # 概要の通り。スキーマを定義し、Validatorクラスに渡して検証する。 &amp;gt;&amp;gt;&amp;gt; from cerberus import Validator &amp;gt;&amp;gt;&amp;gt; schema = {&amp;#39;name&amp;#39;: {&amp;#39;type&amp;#39;: &amp;#39;string&amp;#39;}} &amp;gt;&amp;gt;&amp;gt; v = Validator(schema) &amp;gt;&amp;gt;&amp;gt; document = {&amp;#39;name&amp;#39;: &amp;#39;john doe&amp;#39;} &amp;gt;&amp;gt;&amp;gt; v.</description>
    </item>
    
    <item>
      <title>【Python】poetryを試してみる</title>
      <link>https://SawaTszm.github.io/post/python-try-poetry/</link>
      <pubDate>Fri, 19 Feb 2021 12:01:46 +0900</pubDate>
      
      <guid>https://SawaTszm.github.io/post/python-try-poetry/</guid>
      <description>poetryとは pythonの環境管理ツールです。
機能としてはpipenvに近い感じでした。
本当に触りだけやってみたリポジトリはこちら。
sample-poetry
インストール $pip install poetry プロジェクトを作る $poetry new sample-project 実行すると下記のファイル・フォルダが作成されます。
sample-project ├── README.rst ├── pyproject.toml ├── sample_project │ └── __init__.py └── tests ├── __init__.py └── test_sample_project.py モジュールの追加 $cd sample-project # pyproject.tomlがある階層で $poetry add [--dev] &amp;lt;package name&amp;gt; これでpoetryが管理している仮想環境内にモジュールが追加されます。
それに伴って、ファイルと依存関係を管理する pyproject.tomlとpoetry.lock が作成されます。
Remove Deoendency $poetry remove &amp;lt;package name&amp;gt; This is very simple :)
Use Virtual Environment # not active $poetry run python -m pytest # active $poetry shell Use Exsting Environment $poetry install [--no-dev] Reference Poetry - Python dependency management and packaging made easy.</description>
    </item>
    
    <item>
      <title>【Python】エラーについて</title>
      <link>https://SawaTszm.github.io/post/python-about-error/</link>
      <pubDate>Fri, 19 Feb 2021 12:01:46 +0900</pubDate>
      
      <guid>https://SawaTszm.github.io/post/python-about-error/</guid>
      <description>知りたかったこと try-catch の有効範囲はどれくらいなのか(呼び出した関数で起きたエラーも拾えるのか) ネストしたエラーの扱いってどうするのが良いんだろう 結論 呼び出された先の例外もキャッチできますφ(･･
調べて知ったこと エラーには構文エラーと例外がある 複数の例外を指定することができる except (RuntimeError, TypeError, NameError): pass exceptは上から順に見て、引っかかったタイミングでそのexcept節内部のみを実行する 最後の except 節では例外名を省いて、ワイルドカードにすることができる しかし、ワイルドカードの except 節は通常のプログラムエラーをたやすく隠してしまうため、注意は必要 Try…exceptの中にはelse節を設けることができる。else節は全てのexcept節よりも後ろに置く try 節で全く例外が創出されなかった時に実行されるコードを記述することができる for arg in sys.argv[1:]: try: f = open(arg, &amp;#39;r&amp;#39;) except OSError: print(&amp;#39;cannot open&amp;#39;, arg) else: print(arg, &amp;#39;has&amp;#39;, len(f.readlines()), &amp;#39;lines&amp;#39;) f.close() 参考：
Python の例外処理（try, except, else, finally） | note.nkmk.me
8. エラーと例外 — Python 3.8.1 ドキュメント
Except 節では例外名の後に変数を指定できる。この変数は例外インスタンスに結び付けられ、instance.argsに例外インスタンス生成時の引数が入る。
例外インスタンスに実装されている__str__はinstance.argsをわざわざ出力しなくても見られるようになっているので、print(inst)で見られる。便利。 例外ハンドラは、try 節の直下で発生した例外を処理するだけではなく、その try 節から(たとえ間接的にでも)呼び出された関数の内部で発生した例外も処理する。(！)
def this_fails(): ... x = 1/0 .</description>
    </item>
    
    <item>
      <title>【Pytyon】リストの重複要素をカウントする</title>
      <link>https://SawaTszm.github.io/post/pytyon-%E3%83%AA%E3%82%B9%E3%83%88%E3%81%AE%E9%87%8D%E8%A4%87%E8%A6%81%E7%B4%A0%E3%82%92%E3%82%AB%E3%82%A6%E3%83%B3%E3%83%88%E3%81%99%E3%82%8B/</link>
      <pubDate>Fri, 19 Feb 2021 12:01:46 +0900</pubDate>
      
      <guid>https://SawaTszm.github.io/post/pytyon-%E3%83%AA%E3%82%B9%E3%83%88%E3%81%AE%E9%87%8D%E8%A4%87%E8%A6%81%E7%B4%A0%E3%82%92%E3%82%AB%E3%82%A6%E3%83%B3%E3%83%88%E3%81%99%E3%82%8B/</guid>
      <description>目的 投票結果を DB に貯めて、その結果を一位から取得したい。
DB 構成は、
Id Recipe int str というシンプルな感じです。
ここからレコードの recipe の値を、[a, b, c, b, ...]と言ったリストに直した際、
「一番投票数の多かったもの」や「投票数が多かった順の要素のリスト」が欲しい。
TL;DR collectionsを使えば比較的簡単にできます。
要素のカウントは collections が便利 import collections votes_list = [a, b, c, b] c = collections.Counter(votes_list) # Counter({&amp;#39;b&amp;#39;: 2, &amp;#39;a&amp;#39;: 1, &amp;#39;c&amp;#39;: 1}) # `要素`: `出現回数` recipe = c.most_common() # [(&amp;#39;b&amp;#39;, 2), (&amp;#39;a&amp;#39;, 1), (&amp;#39;c&amp;#39;, 1)] # 出現回数が多い順に並べ替えてくれる recipe = c.most_common()[0][0] # b 参考にさせていただいたもの お世話になりました。
collections — コンテナデータ型 — Python 3.8.1 ドキュメント</description>
    </item>
    
    <item>
      <title>【Redis】ってなんぞや</title>
      <link>https://SawaTszm.github.io/post/summary-of-redis/</link>
      <pubDate>Fri, 19 Feb 2021 12:01:46 +0900</pubDate>
      
      <guid>https://SawaTszm.github.io/post/summary-of-redis/</guid>
      <description>目的 案件で触らせてもらうことになったぜ
何もわからないぜ
という状態なので、自分が調べたことについてまとめておきます。
Radis とは REmote DIctionary Serverの略 読んで字の如く、ネットワーク接続されたKey-Value型のNoSQLデータベース 永続化可能なインメモリデータベース オープンソースのプロジェクトで、Redis Labsがスポンサー。中身はC言語 AWS上でもRedis-serverが提供されている 様々なデータ構造をサポートしている STRING LIST SET HASH ZSET (ソート済みのset) 補足：インメモリDB すべてのデータをコンピュータのメインメモリ上に展開しながら動作する仕組みのことです。
コンピュータ(サーバ)の電源が落ちれば消えてしまうので、永続化の手段としてデータを別途どこかに保存することがあります。
インメモリデータベースでサーバが落ちたらデータはどうなる？ インメモリとカラム型データベースの可能性を調べる（その3） － Publickey
インストールと動作確認 少し挙動を試してみたいだけなら、公式チュートリアルの画面でコマンドを叩くことができます。
Try Redis
Macであれば下記brewコマンドで一発。
$brew install Redis インストールできたら、サーバを立ち上げてみます。
$ redis-server # 立ち上がったら別のタブで動作確認 $ redis-cli 127.0.0.1:6379&amp;gt; set test &amp;#34;hoge&amp;#34; OK 127.0.0.1:6379&amp;gt; get test &amp;#34;hoge&amp;#34; 動作確認までできました。
このコマンドを叩く先のredis-serverがローカルにあるかAWS上のサービスとしてあるかが変わってくるだけで、cli側の設定や叩き方は基本的に変わりません。
(PythonなんかでRedisクライアントを作成する時に指すHOSTが変わってくるくらい、の認識です)
データのタイプ Redisは前述の通り様々なデータタイプに対応しています。
どのデータタイプを使用するかによって、コマンドやデータの指定方法が違ってきます。
コマンドの詳細などは公式ドキュメントで。
Data types – Redis
Strings 最も基本的な、KeyとValueが1:1な構造。
Key = valueの形。
バイナリセーフ(JPEG画像やシリアル化されたRubyオブジェクトなども格納可能) 最大512MBまで 127.</description>
    </item>
    
    <item>
      <title>Killedと言われないためにDockerのメモリ割り当てを増やす</title>
      <link>https://SawaTszm.github.io/post/increase-memory-allocation-of-docker-to-avoid-killed/</link>
      <pubDate>Fri, 19 Feb 2021 12:01:46 +0900</pubDate>
      
      <guid>https://SawaTszm.github.io/post/increase-memory-allocation-of-docker-to-avoid-killed/</guid>
      <description>目的 laravelプロジェクトにawsのs3アダプタをインストールしようとして、dockerコンテナ内に入ってcomposer require league/flysystem-aws-s3-v3 ~1.0を実行したら下記の通りKillされました。
root@9f833b0a116f:/var/www/html/laravel# composer require league/flysystem-aws-s3-v3 ~1.0 ./composer.json has been updated Loading composer repositories with package information Updating dependencies (including require-dev) Killed ｺﾛｻﾅｲﾃﾞ……
これを、ちゃんと殺されずにインストール完了させたいので色々調べました。
TL;DR Docker for Macのメモリ割り当てをできる範囲で増やす。
解決法 調べたこと まず、Killedがどういう時に発動するのかを調べました。
ら、OOM Killerと呼ばれる動作らしいです。
OOM Killer（Out of Memory Killer）は，システムが実メモリーと仮想メモリー空間（スワップ領域）を使い切り，必要なメモリー領域を新たに確保できない場合に，プロセスを強制終了させて空きメモリーを確保する，Linuxカーネルの仕組みです。OOM Killerは，空きメモリーが確保できないことによりシステム自体が停止するという最悪の事態を避けるために用意されています。
日経XTECHさんより引用
強制的にプロセスがKillされてしまうのは、システム自体が止まってしまわないようにOOM Killerさんが働いた結果らしいです。
つまり、今回の原因はメモリ不足。
Docker for macで、Preferences &amp;gt; Resources &amp;gt; Memoryを見てみると、現在は3.75GB割り当てしていることがわかりました。Swapは1GB。
合わせてMacのアクティビティモニタでdockerが使っているメモリを調べて見ると、割り当て分ほとんど使い切っていました。
実行したこと Docker for macのPreferences &amp;gt; Resources &amp;gt; Memoryから、割り当てのメモリをできる範囲で増やしました。
mac自体は16GBなので、まぁ一回様子見て5GBまであげてみることに。
改めてcomposer require league/flysystem-aws-s3-v3 ~1.0を実行。
root@9f833b0a116f:/var/www/html/laravel# composer require league/flysystem-aws-s3-v3 Using version ^1.</description>
    </item>
    
    <item>
      <title>2021 02 09-19 Diary</title>
      <link>https://SawaTszm.github.io/post/diary-2021-02-09/</link>
      <pubDate>Tue, 09 Feb 2021 14:11:32 +0900</pubDate>
      
      <guid>https://SawaTszm.github.io/post/diary-2021-02-09/</guid>
      <description>気になったニュース PythonのデフォルトエンコーディングをUTF-8にするために - methaneのブログ
PyCon JP Blog: PyCon JP 2021 カンファレンス開催日程仮決定のお知らせ
楽しみ
Facebookが大規模スケーラビリティへの挑戦で学んだこと（前編）～800億枚の写真データとPHPのスケーラビリティ問題 － Publickey
社内勉強会で AWS Organizations 基礎の話をしました | DevelopersIO
他 書くだけ書いてPushするのを忘れがち。</description>
    </item>
    
    <item>
      <title>2021 02 02 Diary</title>
      <link>https://SawaTszm.github.io/post/diary-2021-02-02/</link>
      <pubDate>Tue, 02 Feb 2021 12:01:46 +0900</pubDate>
      
      <guid>https://SawaTszm.github.io/post/diary-2021-02-02/</guid>
      <description>気になったニュース 【？】「github」の読み方は「ギットハブ」でも「ジットハブ」でもありません。「イ」です。 - Togetter
Ghoti理論って言うものがあって、これはfishと同じ読み方らしい。これに則って読むとgithubが「イ」になる。そうなんだ……
ASCII.jp：Apple Watchがあるとマスクを着けたままiPhoneのロック解除が可能に
ありがとうApple ありがとう世界
Python向け科学計算パッケージの最新版「NumPy 1.20.0」がリリース：CodeZine（コードジン）
「NumPy 1.20.0」はこれまでで最大となるアップデートで、Python 3.7～3.9をサポートし、Python 3.6のサポートは終了している。
新しく使うときに3.6以下使うことはないと思うけど、一応頭の片隅で覚えておこう。
他 原神くんの事前ダウンロードも終えて準備万端なので明日が楽しみです。</description>
    </item>
    
    <item>
      <title>2021 02 01 Diary</title>
      <link>https://SawaTszm.github.io/post/diary-2021-02-01/</link>
      <pubDate>Mon, 01 Feb 2021 11:06:43 +0900</pubDate>
      
      <guid>https://SawaTszm.github.io/post/diary-2021-02-01/</guid>
      <description>気になったニュース gitにおけるコミットログ/メッセージ例文集100
Access control for GitHub Pages - GitHub Changelog
社内ドキュメントとしての運用とかにも良さそう。
エディタ+ mdファイル編集 + GithubにPushで完結するのはとても健康にいい。
調べたこと BigQueryへの差分アップロード Insert/Upsertを意識するんじゃなくて、updated_dateを持った状態で複数データ入れてしまう方がいいかなと思った。
Insert/Upsertを実現できるmergeはテーブルサイズ分課金されるので（SELECTと同じ）、日次で取り込むデータサイクルに入れるのは避けたい。
対して上書きでなくて重複データをInsertする方法では、
集計するときはCOUNT(DISTINCT x)で重複削除すればいい 重複データが積もってきたらSQLで整理ができる ので、こっちの方が良さげ。
そうすればBQに移行する日次データは「その日に新規作成されたもの」と「その日に上書きされたもの」だけでよくなる。
参考：
BigQuery にデータを差分ロード（UPSERT）する方法まとめ | Developers.IO
BigQueryでUPDATE？？ - Qiita
標準 SQL の集計関数 | BigQuery | Google Cloud
SQLのORについて OR使わないといけないかなと思って調べてたら下記記事を見つけた。
PostgreSQL: 「OR」を避けてパフォーマンスを向上させよう（翻訳）
「まだマシ」なダメな例をやろうとしていたのと、後半の話は知らなかったのでﾁｮｯﾄ勉強になった。
SQL、苦手意識があって若干避けてきたけどそろそろ向き合うべき時が来た気がする。
他 原神くんの1.3アプデ、鍾離先生の上方修正が確定したので楽しみです。
コントローラーで操作できるようになるのも楽しみ。
これでもうボタンスカって敵の攻撃が直撃するミスがなくなるんだ……。</description>
    </item>
    
    <item>
      <title>【ディープリンク】ってなんぞや</title>
      <link>https://SawaTszm.github.io/post/summary-of-deep-link/</link>
      <pubDate>Thu, 28 Jan 2021 19:10:59 +0900</pubDate>
      
      <guid>https://SawaTszm.github.io/post/summary-of-deep-link/</guid>
      <description>目的 「LINEBOT くんのメッセージをタップしたらアプリに飛ぶようにしてほしい！」
という要件を貰ったけど、
そのあたり全く初見だったので調べてまとめてみました。
ディープリンクとは 任意のアプリに遷移できるリンク(URL)のことです。
アプリに遷移できるだけでなく、更にその中の特定の画面を指定して遷移することができます。
スマホでTwitterやYoutubeのリンクをタップした時に、アプリが立ち上がって見たかった投稿や動画を開いてくれることってありますよね？ あの仕組みのことです。
プラットフォームごとのディープリンク対応 プラットフォーム 種類 対応 URL Android App links Android6.0 以降 WebURL Android App Indexing Android WebURL Apple universal links iOS9 以降 WebURL どちらも Custom URL Scheme iOS,Android カスタム URL Android(Google) App Links App Linksはオープンソースのアプリ連携サービスです。Facebookが提供しています。
https:// から始まる URL を利用できます。
メリット WebURL から直接アプリを起動できる Android 特有のアプリ選択画面を飛ばせる デメリット 認証情報ファイルを https 通信可能なサーバに上げておく必要がある android 6.0(2015 年 10 月リリース)以降しか対応していない 設定方法 下記が参考になりました。
App Linksに対応してみた - Qiita
App Indexing App Indexingは、その名の通りアプリのコンテンツをインデックスして、Google検索の結果からアプリに直接遷移することができるサービスです。Googleが提供しています。</description>
    </item>
    
    <item>
      <title>2021-01-28 Diary</title>
      <link>https://SawaTszm.github.io/post/diary-2021-01-28/</link>
      <pubDate>Thu, 28 Jan 2021 14:20:35 +0900</pubDate>
      
      <guid>https://SawaTszm.github.io/post/diary-2021-01-28/</guid>
      <description>気になったニュース Pyston 2.1、本家Python 3.8/3.9よりも十分に高いパフォーマンスを実現 | マイナビニュース
Dropboxが開発元（？）って言うのは知らなかった……
やってみたこと サイト構築 Github Pages と Hugoでサイト作ってみました。（これ）
参考にさせてもらったサイト：
GitHub PagesとHugoでブログをつくった
Hugo+Github Pagesで新しい個人ウェブサイトを作った - DEV Community
使用テーマはこれ：
Beautifulhugo | Hugo Themes
拡張機能系もありそうなのでゆっくり見ていきたいです。
あと、Hugoの中身はGo言語らしいので、Go勉強し始めることがあったらソース読みたいなと思いました。</description>
    </item>
    
  </channel>
</rss>
